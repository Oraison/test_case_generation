{"language": "python3", "Difficulty": "D", "name": "1548_D1. Gregor and the Odd Cows (Easy)", "description": "This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.\n\nThere are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.\n\nThere are an infinite number of cows on the plane, one at every point with integer coordinates.\n\nGregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.\n\nFind the number of interesting fences.\n\nInput\n\nThe first line contains the integer n (3 \u2264 n \u2264 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.\n\nEach of the next n line contains two integers x and y (0 \u2264 x,y \u2264 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.\n\nOutput\n\nPrint a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.\n\nExamples\n\nInput\n\n\n3\n0 0\n2 0\n0 4\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n5\n0 0\n2 16\n30 14\n4 6\n2 10\n\n\nOutput\n\n\n3\n\nNote\n\nIn the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.\n\n<image>\n\nIn the second example, there are 3 interesting fences. \n\n  * (0,0) \u2014 (30,14) \u2014 (2,10) \n  * (2,16) \u2014 (30,14) \u2014 (2,10) \n  * (30,14) \u2014 (4,6) \u2014 (2,10) ", "test_cases": ["input: \"5\\n0 0\\n2 16\\n30 14\\n4 6\\n2 10\\n\"\noutput: \"3\\n\"\n", "input: \"3\\n0 0\\n2 0\\n0 4\\n\"\noutput: \"1\\n\"\n"], "private_tests": ["input: \"20\\n200 716\\n88 526\\n434 134\\n996 890\\n718 220\\n820 462\\n614 178\\n848 208\\n724 536\\n124 710\\n408 228\\n846 606\\n222 32\\n642 180\\n694 964\\n438 994\\n718 524\\n688 692\\n126 494\\n102 116\\n\"\noutput: \"650\\n\"\n", "input: \"4\\n12 10\\n6 14\\n2 6\\n6 12\\n\"\noutput: \"2\\n\"\n"], "solutions": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nN = int(input())\nA = [0] * 4\nfor _ in range(N):\n    x, y = map(int, input().split())\n    x, y = x // 2, y // 2\n    A[(x % 2) * 2 + (y % 2)] += 1\n\nans = 0\nfor i in range(4):\n    a = A[i]\n    s = a * (a - 1) // 2\n    ans += s * (a - 2) // 3\n    for j in range(4):\n        if i == j: continue\n        b = A[j]\n        ans += s * b\nprint(ans)\n\n"}
{"language": "python3", "Difficulty": "D", "name": "1548_D1. Gregor and the Odd Cows (Easy)", "description": "This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.\n\nThere are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.\n\nThere are an infinite number of cows on the plane, one at every point with integer coordinates.\n\nGregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.\n\nFind the number of interesting fences.\n\nInput\n\nThe first line contains the integer n (3 \u2264 n \u2264 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.\n\nEach of the next n line contains two integers x and y (0 \u2264 x,y \u2264 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.\n\nOutput\n\nPrint a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.\n\nExamples\n\nInput\n\n\n3\n0 0\n2 0\n0 4\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n5\n0 0\n2 16\n30 14\n4 6\n2 10\n\n\nOutput\n\n\n3\n\nNote\n\nIn the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.\n\n<image>\n\nIn the second example, there are 3 interesting fences. \n\n  * (0,0) \u2014 (30,14) \u2014 (2,10) \n  * (2,16) \u2014 (30,14) \u2014 (2,10) \n  * (30,14) \u2014 (4,6) \u2014 (2,10) ", "test_cases": ["input: \"5\\n0 0\\n2 16\\n30 14\\n4 6\\n2 10\\n\"\noutput: \"3\\n\"\n", "input: \"3\\n0 0\\n2 0\\n0 4\\n\"\noutput: \"1\\n\"\n"], "private_tests": ["input: \"20\\n200 716\\n88 526\\n434 134\\n996 890\\n718 220\\n820 462\\n614 178\\n848 208\\n724 536\\n124 710\\n408 228\\n846 606\\n222 32\\n642 180\\n694 964\\n438 994\\n718 524\\n688 692\\n126 494\\n102 116\\n\"\noutput: \"650\\n\"\n", "input: \"4\\n12 10\\n6 14\\n2 6\\n6 12\\n\"\noutput: \"2\\n\"\n"], "solutions": "\ndef divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M//i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n//i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n//=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res//x * (x-1)\n            while n%x==0:\n                n //= x\n    if n!=1:\n        res = res//n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n//=b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d // (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() // 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n // g): return n // g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n //= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n //= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\n#Z[i]:length of the longest list starting from S[i] which is also a prefix of S\n#O(|S|)\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n,mod=0):\n        self.BIT = [0]*(n+1)\n        self.num = n\n        self.mod = mod\n\n    def query(self,idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        mod = self.mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass SegmentTree:\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        self.size = n\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        if r==self.size:\n            r = self.num\n\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\n    def bisect_l(self,l,r,x):\n        l += self.num\n        r += self.num\n        Lmin = -1\n        Rmin = -1\n        while l<r:\n            if l & 1:\n                if self.tree[l] <= x and Lmin==-1:\n                    Lmin = l\n                l += 1\n            if r & 1:\n                if self.tree[r-1] <=x:\n                    Rmin = r-1\n            l >>= 1\n            r >>= 1\n\n        if Lmin != -1:\n            pos = Lmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        elif Rmin != -1:\n            pos = Rmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        else:\n            return -1\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import gcd,log\n\ninput = lambda :sys.stdin.buffer.readline()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nn = int(input())\nxy = [mi() for i in range(n)]\nfor i in range(n):\n    x,y = xy[i]\n    xy[i] = (x//2,y//2)\n\nparity = [0 for i in range(4)]\nfor x,y in xy:\n    p = 2 * (x&1) + (y&1)\n    parity[p] += 1\n\nres = 0\nfor i in range(n):\n    for j in range(i+1,n):\n        x0,y0 = xy[i]\n        x1,y1 = xy[j]\n\n        if (x0-x1)&1==0 and (y0-y1)&1==0:\n            t = 0\n        else:\n            t = 1\n\n        for p in range(4):\n            x2 = p>>1 & 1\n            y2 = p & 1\n\n            tmp = t\n\n            if (x0-x2)&1 or (y0-y2)&1:\n                tmp += 1\n            if (x1-x2)&1 or (y1-y2)&1:\n                tmp += 1\n\n            if tmp&1==0:\n                plus = parity[p]\n                if 2 * (x0&1) + (y0&1)==p:\n                    plus -= 1\n                if 2 * (x1&1) + (y1&1)==p:\n                    plus -= 1\n                res += plus\n\nprint(res//3)\n"}
{"language": "python3", "Difficulty": "D", "name": "1548_D1. Gregor and the Odd Cows (Easy)", "description": "This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.\n\nThere are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.\n\nThere are an infinite number of cows on the plane, one at every point with integer coordinates.\n\nGregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.\n\nFind the number of interesting fences.\n\nInput\n\nThe first line contains the integer n (3 \u2264 n \u2264 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.\n\nEach of the next n line contains two integers x and y (0 \u2264 x,y \u2264 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.\n\nOutput\n\nPrint a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.\n\nExamples\n\nInput\n\n\n3\n0 0\n2 0\n0 4\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n5\n0 0\n2 16\n30 14\n4 6\n2 10\n\n\nOutput\n\n\n3\n\nNote\n\nIn the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.\n\n<image>\n\nIn the second example, there are 3 interesting fences. \n\n  * (0,0) \u2014 (30,14) \u2014 (2,10) \n  * (2,16) \u2014 (30,14) \u2014 (2,10) \n  * (30,14) \u2014 (4,6) \u2014 (2,10) ", "test_cases": ["input: \"5\\n0 0\\n2 16\\n30 14\\n4 6\\n2 10\\n\"\noutput: \"3\\n\"\n", "input: \"3\\n0 0\\n2 0\\n0 4\\n\"\noutput: \"1\\n\"\n"], "private_tests": ["input: \"20\\n200 716\\n88 526\\n434 134\\n996 890\\n718 220\\n820 462\\n614 178\\n848 208\\n724 536\\n124 710\\n408 228\\n846 606\\n222 32\\n642 180\\n694 964\\n438 994\\n718 524\\n688 692\\n126 494\\n102 116\\n\"\noutput: \"650\\n\"\n", "input: \"4\\n12 10\\n6 14\\n2 6\\n6 12\\n\"\noutput: \"2\\n\"\n"], "solutions": "import math,sys\ninput=sys.stdin.readline\nn=int(input())\np=[list(map(int,input().split())) for _ in range(n)]\nans=0\ncnt=0\nr=[[0]*n for _ in range(n)]\nq=[0]*n\nfor i in range(n):\n    for j in range(i+1,n):\n        if math.gcd(abs(p[i][0]-p[j][0]),abs(p[i][1]-p[j][1]))%4==0:\n            cnt+=1\n            r[i][j]=1\n            q[i]+=1\n            ans+=n-2\nfor i in range(n):\n    for j in range(1,n):\n        if r[i][j]==1:\n            ans-=q[j]*2\nprint(ans)\n"}
{"language": "python3", "Difficulty": "D", "name": "1548_D1. Gregor and the Odd Cows (Easy)", "description": "This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.\n\nThere are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.\n\nThere are an infinite number of cows on the plane, one at every point with integer coordinates.\n\nGregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.\n\nFind the number of interesting fences.\n\nInput\n\nThe first line contains the integer n (3 \u2264 n \u2264 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.\n\nEach of the next n line contains two integers x and y (0 \u2264 x,y \u2264 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.\n\nOutput\n\nPrint a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.\n\nExamples\n\nInput\n\n\n3\n0 0\n2 0\n0 4\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n5\n0 0\n2 16\n30 14\n4 6\n2 10\n\n\nOutput\n\n\n3\n\nNote\n\nIn the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.\n\n<image>\n\nIn the second example, there are 3 interesting fences. \n\n  * (0,0) \u2014 (30,14) \u2014 (2,10) \n  * (2,16) \u2014 (30,14) \u2014 (2,10) \n  * (30,14) \u2014 (4,6) \u2014 (2,10) ", "test_cases": ["input: \"5\\n0 0\\n2 16\\n30 14\\n4 6\\n2 10\\n\"\noutput: \"3\\n\"\n", "input: \"3\\n0 0\\n2 0\\n0 4\\n\"\noutput: \"1\\n\"\n"], "private_tests": ["input: \"20\\n200 716\\n88 526\\n434 134\\n996 890\\n718 220\\n820 462\\n614 178\\n848 208\\n724 536\\n124 710\\n408 228\\n846 606\\n222 32\\n642 180\\n694 964\\n438 994\\n718 524\\n688 692\\n126 494\\n102 116\\n\"\noutput: \"650\\n\"\n", "input: \"4\\n12 10\\n6 14\\n2 6\\n6 12\\n\"\noutput: \"2\\n\"\n"], "solutions": "mod = 1000000007\neps = 10**-9\n\n\ndef main():\n    import sys\n    input = sys.stdin.buffer.readline\n\n    N = int(input())\n    XY = []\n    for _ in range(N):\n        XY.append(tuple(map(int, input().split())))\n\n    ans1 = ans2 = 0\n    for i in range(N):\n        cnt = [0] * 4\n        xi, yi = XY[i]\n        for j in range(N):\n            if j == i:\n                continue\n            xj, yj = XY[j]\n            if (xi - xj)%4 == 0 and (yi - yj)%4 == 0:\n                cnt[0] += 1\n            elif (xi - xj)%4 == 2 and (yi - yj)%4 == 0:\n                cnt[1] += 1\n            elif (xi - xj)%4 == 0 and (yi - yj)%4 == 2:\n                cnt[2] += 1\n            else:\n                cnt[3] += 1\n        ans1 += cnt[0] * (cnt[0] - 1) // 2\n        ans2 += cnt[1] * (cnt[1] - 1) // 2\n        ans2 += cnt[2] * (cnt[2] - 1) // 2\n        ans2 += cnt[3] * (cnt[3] - 1) // 2\n    assert ans1 % 3 == 0\n    print(ans1 // 3 + ans2)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"language": "python3", "Difficulty": "D", "name": "1548_D1. Gregor and the Odd Cows (Easy)", "description": "This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.\n\nThere are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.\n\nThere are an infinite number of cows on the plane, one at every point with integer coordinates.\n\nGregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.\n\nFind the number of interesting fences.\n\nInput\n\nThe first line contains the integer n (3 \u2264 n \u2264 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.\n\nEach of the next n line contains two integers x and y (0 \u2264 x,y \u2264 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.\n\nOutput\n\nPrint a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.\n\nExamples\n\nInput\n\n\n3\n0 0\n2 0\n0 4\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n5\n0 0\n2 16\n30 14\n4 6\n2 10\n\n\nOutput\n\n\n3\n\nNote\n\nIn the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.\n\n<image>\n\nIn the second example, there are 3 interesting fences. \n\n  * (0,0) \u2014 (30,14) \u2014 (2,10) \n  * (2,16) \u2014 (30,14) \u2014 (2,10) \n  * (30,14) \u2014 (4,6) \u2014 (2,10) ", "test_cases": ["input: \"5\\n0 0\\n2 16\\n30 14\\n4 6\\n2 10\\n\"\noutput: \"3\\n\"\n", "input: \"3\\n0 0\\n2 0\\n0 4\\n\"\noutput: \"1\\n\"\n"], "private_tests": ["input: \"20\\n200 716\\n88 526\\n434 134\\n996 890\\n718 220\\n820 462\\n614 178\\n848 208\\n724 536\\n124 710\\n408 228\\n846 606\\n222 32\\n642 180\\n694 964\\n438 994\\n718 524\\n688 692\\n126 494\\n102 116\\n\"\noutput: \"650\\n\"\n", "input: \"4\\n12 10\\n6 14\\n2 6\\n6 12\\n\"\noutput: \"2\\n\"\n"], "solutions": "n = int(input())\nnum = [0, 0, 0, 0]\n\nfor _ in range(n):\n    x, y = map(int, input().split())\n    num[bool(x&2) + (y&2)] += 1\n\nprint((n*(n-1)*(n-2))//6 - num[0]*num[1]*num[2] - num[0]*num[1]*num[3] - num[0]*num[2]*num[3] - num[1]*num[2]*num[3])\n"}
{"language": "python3", "Difficulty": "D", "name": "1548_D1. Gregor and the Odd Cows (Easy)", "description": "This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.\n\nThere are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.\n\nThere are an infinite number of cows on the plane, one at every point with integer coordinates.\n\nGregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.\n\nFind the number of interesting fences.\n\nInput\n\nThe first line contains the integer n (3 \u2264 n \u2264 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.\n\nEach of the next n line contains two integers x and y (0 \u2264 x,y \u2264 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.\n\nOutput\n\nPrint a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.\n\nExamples\n\nInput\n\n\n3\n0 0\n2 0\n0 4\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n5\n0 0\n2 16\n30 14\n4 6\n2 10\n\n\nOutput\n\n\n3\n\nNote\n\nIn the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.\n\n<image>\n\nIn the second example, there are 3 interesting fences. \n\n  * (0,0) \u2014 (30,14) \u2014 (2,10) \n  * (2,16) \u2014 (30,14) \u2014 (2,10) \n  * (30,14) \u2014 (4,6) \u2014 (2,10) ", "test_cases": ["input: \"5\\n0 0\\n2 16\\n30 14\\n4 6\\n2 10\\n\"\noutput: \"3\\n\"\n", "input: \"3\\n0 0\\n2 0\\n0 4\\n\"\noutput: \"1\\n\"\n"], "private_tests": ["input: \"20\\n200 716\\n88 526\\n434 134\\n996 890\\n718 220\\n820 462\\n614 178\\n848 208\\n724 536\\n124 710\\n408 228\\n846 606\\n222 32\\n642 180\\n694 964\\n438 994\\n718 524\\n688 692\\n126 494\\n102 116\\n\"\noutput: \"650\\n\"\n", "input: \"4\\n12 10\\n6 14\\n2 6\\n6 12\\n\"\noutput: \"2\\n\"\n"], "solutions": "n = int(input())\nposts = [tuple(map(int, input().split())) for _ in range(n)]\n\nbuckets = [0] * 4\nfor x, y in posts:\n    i = 0\n    if x % 4:\n        i += 1\n    if y % 4:\n        i += 2\n    buckets[i] += 1\n\nout = 0\nfor v in buckets:\n    out += (v * (v - 1) * (v - 2)) // 6\n    out += (v * (v-1))//2 * (n -v)\nprint(out)\n"}
{"language": "python3", "Difficulty": "D", "name": "1548_D1. Gregor and the Odd Cows (Easy)", "description": "This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.\n\nThere are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.\n\nThere are an infinite number of cows on the plane, one at every point with integer coordinates.\n\nGregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.\n\nFind the number of interesting fences.\n\nInput\n\nThe first line contains the integer n (3 \u2264 n \u2264 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.\n\nEach of the next n line contains two integers x and y (0 \u2264 x,y \u2264 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.\n\nOutput\n\nPrint a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.\n\nExamples\n\nInput\n\n\n3\n0 0\n2 0\n0 4\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n5\n0 0\n2 16\n30 14\n4 6\n2 10\n\n\nOutput\n\n\n3\n\nNote\n\nIn the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.\n\n<image>\n\nIn the second example, there are 3 interesting fences. \n\n  * (0,0) \u2014 (30,14) \u2014 (2,10) \n  * (2,16) \u2014 (30,14) \u2014 (2,10) \n  * (30,14) \u2014 (4,6) \u2014 (2,10) ", "test_cases": ["input: \"5\\n0 0\\n2 16\\n30 14\\n4 6\\n2 10\\n\"\noutput: \"3\\n\"\n", "input: \"3\\n0 0\\n2 0\\n0 4\\n\"\noutput: \"1\\n\"\n"], "private_tests": ["input: \"20\\n200 716\\n88 526\\n434 134\\n996 890\\n718 220\\n820 462\\n614 178\\n848 208\\n724 536\\n124 710\\n408 228\\n846 606\\n222 32\\n642 180\\n694 964\\n438 994\\n718 524\\n688 692\\n126 494\\n102 116\\n\"\noutput: \"650\\n\"\n", "input: \"4\\n12 10\\n6 14\\n2 6\\n6 12\\n\"\noutput: \"2\\n\"\n"], "solutions": "from collections import defaultdict\ndef c2(x):\n    return x*(x-1)//2\ndef c3(x):\n    return x*(x-1)*(x-2) // 6\nif __name__ == \"__main__\":\n    while True:\n        try:\n            counts = defaultdict(int)\n            n = int(input().strip())\n            for _ in range(n):\n                x, y = map(int, input().strip().split())\n                counts[(x%4, y%4)] += 1\n            ans = c3(counts[(0,0)]) + c3(counts[(0, 2)]) + c3(counts[(2,0)]) + c3(counts[(2, 2)])\n            ans += c2(counts[(0,0)])*(n - counts[(0, 0)]) + c2(counts[(0, 2)])*(n - counts[(0, 2)]) +  c2(counts[(2, 0)])*(n - counts[(2, 0)]) +  c2(counts[(2, 2)])*(n - counts[(2, 2)])\n            print(ans)\n        except EOFError:\n            break\n"}
{"language": "python3", "Difficulty": "D", "name": "1548_D1. Gregor and the Odd Cows (Easy)", "description": "This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.\n\nThere are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.\n\nThere are an infinite number of cows on the plane, one at every point with integer coordinates.\n\nGregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.\n\nFind the number of interesting fences.\n\nInput\n\nThe first line contains the integer n (3 \u2264 n \u2264 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.\n\nEach of the next n line contains two integers x and y (0 \u2264 x,y \u2264 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.\n\nOutput\n\nPrint a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.\n\nExamples\n\nInput\n\n\n3\n0 0\n2 0\n0 4\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n5\n0 0\n2 16\n30 14\n4 6\n2 10\n\n\nOutput\n\n\n3\n\nNote\n\nIn the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.\n\n<image>\n\nIn the second example, there are 3 interesting fences. \n\n  * (0,0) \u2014 (30,14) \u2014 (2,10) \n  * (2,16) \u2014 (30,14) \u2014 (2,10) \n  * (30,14) \u2014 (4,6) \u2014 (2,10) ", "test_cases": ["input: \"5\\n0 0\\n2 16\\n30 14\\n4 6\\n2 10\\n\"\noutput: \"3\\n\"\n", "input: \"3\\n0 0\\n2 0\\n0 4\\n\"\noutput: \"1\\n\"\n"], "private_tests": ["input: \"20\\n200 716\\n88 526\\n434 134\\n996 890\\n718 220\\n820 462\\n614 178\\n848 208\\n724 536\\n124 710\\n408 228\\n846 606\\n222 32\\n642 180\\n694 964\\n438 994\\n718 524\\n688 692\\n126 494\\n102 116\\n\"\noutput: \"650\\n\"\n", "input: \"4\\n12 10\\n6 14\\n2 6\\n6 12\\n\"\noutput: \"2\\n\"\n"], "solutions": "from math import gcd\n\nM = 4\n\nn = int(input())\ncnt = [0] * M * M\nfor i in range(n):\n    x, y = map(int, input().split())\n    cnt[x % M * M + y % M] += 1\n\n\ndef boundary(i, j):\n    return gcd(i % M - j % M, i // M - j // M)\n\n\nans = 0\nfor i in range(M * M):\n    for j in range(i, M * M):\n        for k in range(j, M * M):\n            if (boundary(i, j) + boundary(i, k) + boundary(j, k)) % 4 == 0:\n                cur = cnt[i]\n                cur = cur * cnt[j] if i != j else cur * (cnt[j] - 1) // 2\n                cur = cur * cnt[k] if j != k else cur * (cnt[k] - 1) // 2 if k != i else cur * (cnt[k] - 2) // 3\n                ans += cur\nprint(ans)\n"}
{"language": "python3", "Difficulty": "A", "name": "1549_A. Gregor and Cryptography", "description": "Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.\n\nGregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.\n\n  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and \n  * 2 \u2264 a < b \u2264 P. \n\n\n\nHelp Gregor find two bases of his favorite prime number!\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 1000).\n\nEach subsequent line contains the integer P (5 \u2264 P \u2264 {10}^9), with P guaranteed to be prime.\n\nOutput\n\nYour output should consist of t lines. Each line should consist of two integers a and b (2 \u2264 a < b \u2264 P). If there are multiple possible solutions, print any.\n\nExample\n\nInput\n\n\n2\n17\n5\n\n\nOutput\n\n\n3 5\n2 4\n\nNote\n\nThe first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.\n\nIn the second query, with P=5, the only solution is a=2 and b=4.", "test_cases": ["input: \"2\\n17\\n5\\n\"\noutput: \"2 16\\n2 4\\n\"\n"], "private_tests": ["input: \"2\\n17\\n5\\n\"\noutput: \"2 16\\n2 4\\n\"\n", "input: \"1\\n55439\\n\"\noutput: \"2 55438\\n\"\n", "input: \"5\\n5\\n7\\n11\\n13\\n19\\n\"\noutput: \"2 4\\n2 6\\n2 10\\n2 12\\n2 18\\n\"\n"], "solutions": "\nt=int(input())\nfor _ in range(t):\n    P=int(input())\n    dic={}\n    for i in range(2,P+1):\n        rem=P%i\n        brk=False\n        # print(i,rem,dic)\n        try:\n            if dic[rem]:\n                print(dic[rem],i)\n                brk=True\n        \n        except KeyError:\n            dic[rem]=i\n        \n        if brk:break\n    \n    "}
{"language": "python3", "Difficulty": "A", "name": "1549_A. Gregor and Cryptography", "description": "Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.\n\nGregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.\n\n  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and \n  * 2 \u2264 a < b \u2264 P. \n\n\n\nHelp Gregor find two bases of his favorite prime number!\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 1000).\n\nEach subsequent line contains the integer P (5 \u2264 P \u2264 {10}^9), with P guaranteed to be prime.\n\nOutput\n\nYour output should consist of t lines. Each line should consist of two integers a and b (2 \u2264 a < b \u2264 P). If there are multiple possible solutions, print any.\n\nExample\n\nInput\n\n\n2\n17\n5\n\n\nOutput\n\n\n3 5\n2 4\n\nNote\n\nThe first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.\n\nIn the second query, with P=5, the only solution is a=2 and b=4.", "test_cases": ["input: \"2\\n17\\n5\\n\"\noutput: \"2 16\\n2 4\\n\"\n"], "private_tests": ["input: \"2\\n17\\n5\\n\"\noutput: \"2 16\\n2 4\\n\"\n", "input: \"1\\n55439\\n\"\noutput: \"2 55438\\n\"\n", "input: \"5\\n5\\n7\\n11\\n13\\n19\\n\"\noutput: \"2 4\\n2 6\\n2 10\\n2 12\\n2 18\\n\"\n"], "solutions": "number = int(input())\nfor i in range(number):\n    chislo = int(input())\n    if chislo%2 == 1:\n        print(2, chislo - 1)\n    else:\n        if chislo %3 == 1:\n            print(3, chislo-1)\n        elif chislo%3 == 2:\n            print(3, chislo - 2)"}
{"language": "python3", "Difficulty": "A", "name": "1549_A. Gregor and Cryptography", "description": "Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.\n\nGregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.\n\n  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and \n  * 2 \u2264 a < b \u2264 P. \n\n\n\nHelp Gregor find two bases of his favorite prime number!\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 1000).\n\nEach subsequent line contains the integer P (5 \u2264 P \u2264 {10}^9), with P guaranteed to be prime.\n\nOutput\n\nYour output should consist of t lines. Each line should consist of two integers a and b (2 \u2264 a < b \u2264 P). If there are multiple possible solutions, print any.\n\nExample\n\nInput\n\n\n2\n17\n5\n\n\nOutput\n\n\n3 5\n2 4\n\nNote\n\nThe first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.\n\nIn the second query, with P=5, the only solution is a=2 and b=4.", "test_cases": ["input: \"2\\n17\\n5\\n\"\noutput: \"2 16\\n2 4\\n\"\n"], "private_tests": ["input: \"2\\n17\\n5\\n\"\noutput: \"2 16\\n2 4\\n\"\n", "input: \"1\\n55439\\n\"\noutput: \"2 55438\\n\"\n", "input: \"5\\n5\\n7\\n11\\n13\\n19\\n\"\noutput: \"2 4\\n2 6\\n2 10\\n2 12\\n2 18\\n\"\n"], "solutions": "# cook your dish here\nt=int(input())\nfor o in range(t):\n    p=int(input())\n    print(2,p-1)\n        "}
