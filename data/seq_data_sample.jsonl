{"language": "cpp", "Difficulty": "C", "name": "1548_C. The Three Little Pigs", "description": "Three little pigs from all over the world are meeting for a convention! Every minute, a triple of 3 new pigs arrives on the convention floor. After the n-th minute, the convention ends.\n\nThe big bad wolf has learned about this convention, and he has an attack plan. At some minute in the convention, he will arrive and eat exactly x pigs. Then he will get away.\n\nThe wolf wants Gregor to help him figure out the number of possible attack plans that involve eating exactly x pigs for various values of x (1 \u2264 x \u2264 3n). Two attack plans are considered different, if they occur at different times or if the sets of little pigs to eat are different.\n\nNote that all queries are independent, that is, the wolf does not eat the little pigs, he only makes plans!\n\nInput\n\nThe first line of input contains two integers n and q (1 \u2264 n \u2264 10^6, 1 \u2264 q \u2264 2\u22c5 10^5), the number of minutes the convention lasts and the number of queries the wolf asks.\n\nEach of the next q lines contains a single integer x_i (1 \u2264 x_i \u2264 3n), the number of pigs the wolf will eat in the i-th query.\n\nOutput\n\nYou should print q lines, with line i representing the number of attack plans if the wolf wants to eat x_i pigs. Since each query answer can be large, output each answer modulo 10^9+7.\n\nExamples\n\nInput\n\n\n2 3\n1\n5\n6\n\n\nOutput\n\n\n9\n6\n1\n\n\nInput\n\n\n5 4\n2\n4\n6\n8\n\n\nOutput\n\n\n225\n2001\n6014\n6939\n\nNote\n\nIn the example test, n=2. Thus, there are 3 pigs at minute 1, and 6 pigs at minute 2. There are three queries: x=1, x=5, and x=6.\n\nIf the wolf wants to eat 1 pig, he can do so in 3+6=9 possible attack plans, depending on whether he arrives at minute 1 or 2.\n\nIf the wolf wants to eat 5 pigs, the wolf cannot arrive at minute 1, since there aren't enough pigs at that time. Therefore, the wolf has to arrive at minute 2, and there are 6 possible attack plans.\n\nIf the wolf wants to eat 6 pigs, his only plan is to arrive at the end of the convention and devour everybody.\n\nRemember to output your answers modulo 10^9+7!", "test_cases": ["input: \"2 3\\n1\\n5\\n6\\n\"\noutput: \"9\\n6\\n1\\n\"\n", "input: \"5 4\\n2\\n4\\n6\\n8\\n\"\noutput: \"225\\n2001\\n6014\\n6939\\n\"\n"], "private_tests": ["input: \"1 3\\n1\\n2\\n3\\n\"\noutput: \"3\\n3\\n1\\n\"\n", "input: \"3 9\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n\"\noutput: \"18\\n54\\n105\\n141\\n132\\n85\\n36\\n9\\n1\\n\"\n"], "solutions": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> inverses(int n, int P) {\n  vector<long long> inv(n + 1, 1);\n  for (int i = 2; i <= n; ++i) inv[i] = inv[P % i] * (P - P / i) % P;\n  return inv;\n}\nconst int mod = 1e9 + 7;\nnamespace combi {\nconst int N = 3e6 + 10;\nint fac[N], ifac[N];\nvoid init() {\n  fac[0] = ifac[0] = 1;\n  auto inv = inverses(N, mod);\n  for (int i = 1; i < N; ++i) {\n    fac[i] = (long long)fac[i - 1] * i % mod;\n    ifac[i] = (long long)ifac[i - 1] * inv[i] % mod;\n  }\n}\nint comb(int n, int k) {\n  return (long long)fac[n] * ifac[n - k] % mod * ifac[k] % mod;\n}\n}  // namespace combi\nusing namespace combi;\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  init();\n  int n, Q;\n  cin >> n >> Q;\n  int sz = 3 * (n + 1);\n  vector<int> p(sz + 1);\n  for (int i = 1; i <= sz; ++i) p[i] = comb(sz, i);\n  for (int i = sz; i >= 3; --i) {\n    p[i - 1] = ((p[i - 1] - 3LL * p[i]) % mod + mod) % mod;\n    p[i - 2] = ((p[i - 2] - 3LL * p[i]) % mod + mod) % mod;\n  }\n  p.erase(p.begin(), p.begin() + 3);\n  for (int x; Q--;) {\n    cin >> x;\n    cout << p[x] << \"\\n\";\n  }\n  return 0;\n}\n"}
{"language": "cpp", "Difficulty": "C", "name": "1548_C. The Three Little Pigs", "description": "Three little pigs from all over the world are meeting for a convention! Every minute, a triple of 3 new pigs arrives on the convention floor. After the n-th minute, the convention ends.\n\nThe big bad wolf has learned about this convention, and he has an attack plan. At some minute in the convention, he will arrive and eat exactly x pigs. Then he will get away.\n\nThe wolf wants Gregor to help him figure out the number of possible attack plans that involve eating exactly x pigs for various values of x (1 \u2264 x \u2264 3n). Two attack plans are considered different, if they occur at different times or if the sets of little pigs to eat are different.\n\nNote that all queries are independent, that is, the wolf does not eat the little pigs, he only makes plans!\n\nInput\n\nThe first line of input contains two integers n and q (1 \u2264 n \u2264 10^6, 1 \u2264 q \u2264 2\u22c5 10^5), the number of minutes the convention lasts and the number of queries the wolf asks.\n\nEach of the next q lines contains a single integer x_i (1 \u2264 x_i \u2264 3n), the number of pigs the wolf will eat in the i-th query.\n\nOutput\n\nYou should print q lines, with line i representing the number of attack plans if the wolf wants to eat x_i pigs. Since each query answer can be large, output each answer modulo 10^9+7.\n\nExamples\n\nInput\n\n\n2 3\n1\n5\n6\n\n\nOutput\n\n\n9\n6\n1\n\n\nInput\n\n\n5 4\n2\n4\n6\n8\n\n\nOutput\n\n\n225\n2001\n6014\n6939\n\nNote\n\nIn the example test, n=2. Thus, there are 3 pigs at minute 1, and 6 pigs at minute 2. There are three queries: x=1, x=5, and x=6.\n\nIf the wolf wants to eat 1 pig, he can do so in 3+6=9 possible attack plans, depending on whether he arrives at minute 1 or 2.\n\nIf the wolf wants to eat 5 pigs, the wolf cannot arrive at minute 1, since there aren't enough pigs at that time. Therefore, the wolf has to arrive at minute 2, and there are 6 possible attack plans.\n\nIf the wolf wants to eat 6 pigs, his only plan is to arrive at the end of the convention and devour everybody.\n\nRemember to output your answers modulo 10^9+7!", "test_cases": ["input: \"2 3\\n1\\n5\\n6\\n\"\noutput: \"9\\n6\\n1\\n\"\n", "input: \"5 4\\n2\\n4\\n6\\n8\\n\"\noutput: \"225\\n2001\\n6014\\n6939\\n\"\n"], "private_tests": ["input: \"1 3\\n1\\n2\\n3\\n\"\noutput: \"3\\n3\\n1\\n\"\n", "input: \"3 9\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n\"\noutput: \"18\\n54\\n105\\n141\\n132\\n85\\n36\\n9\\n1\\n\"\n"], "solutions": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nconst long long mod = 1e9 + 7;\nlong long n, q, fact[4000005], invfact[4000005], dp[3000005][3], inv3;\nlong long inv(long long a) {\n  long long rez = 1;\n  long long b = mod - 2;\n  while (b) {\n    if (b & 1) rez = (rez * a) % mod;\n    b /= 2;\n    a = (a * a) % mod;\n  }\n  return rez;\n}\nlong long comb(long long a, long long b) {\n  if (a < 0 || b < 0 || a < b) return 0;\n  long long rez = (fact[a] * invfact[b]) % mod;\n  rez = (rez * invfact[a - b]) % mod;\n  return rez;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  fact[0] = invfact[0] = 1;\n  for (long long i = 1; i <= 3 * n; i++) fact[i] = (fact[i - 1] * i) % mod;\n  invfact[3 * n] = inv(fact[3 * n]);\n  for (long long i = 3 * n - 1; i >= 1; i--)\n    invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n  dp[0][0] = dp[0][1] = dp[0][2] = n;\n  inv3 = inv(3);\n  for (long long x = 1; x <= 3 * n; x++) {\n    long long suma = comb(3 * n, x + 1);\n    long long a = dp[x - 1][0];\n    long long b = dp[x - 1][1];\n    long long val = suma - 2 * a - b;\n    while (val < 0) val += mod;\n    val = (val * inv3) % mod;\n    dp[x][0] = val;\n    dp[x][1] = (dp[x][0] + a) % mod;\n    dp[x][2] = (dp[x][1] + b) % mod;\n  }\n  cin >> q;\n  while (q--) {\n    long long x;\n    cin >> x;\n    cout << (dp[x][0] + comb(3 * n, x)) % mod << '\\n';\n  }\n  return 0;\n}\n"}
{"language": "cpp", "Difficulty": "C", "name": "1548_C. The Three Little Pigs", "description": "Three little pigs from all over the world are meeting for a convention! Every minute, a triple of 3 new pigs arrives on the convention floor. After the n-th minute, the convention ends.\n\nThe big bad wolf has learned about this convention, and he has an attack plan. At some minute in the convention, he will arrive and eat exactly x pigs. Then he will get away.\n\nThe wolf wants Gregor to help him figure out the number of possible attack plans that involve eating exactly x pigs for various values of x (1 \u2264 x \u2264 3n). Two attack plans are considered different, if they occur at different times or if the sets of little pigs to eat are different.\n\nNote that all queries are independent, that is, the wolf does not eat the little pigs, he only makes plans!\n\nInput\n\nThe first line of input contains two integers n and q (1 \u2264 n \u2264 10^6, 1 \u2264 q \u2264 2\u22c5 10^5), the number of minutes the convention lasts and the number of queries the wolf asks.\n\nEach of the next q lines contains a single integer x_i (1 \u2264 x_i \u2264 3n), the number of pigs the wolf will eat in the i-th query.\n\nOutput\n\nYou should print q lines, with line i representing the number of attack plans if the wolf wants to eat x_i pigs. Since each query answer can be large, output each answer modulo 10^9+7.\n\nExamples\n\nInput\n\n\n2 3\n1\n5\n6\n\n\nOutput\n\n\n9\n6\n1\n\n\nInput\n\n\n5 4\n2\n4\n6\n8\n\n\nOutput\n\n\n225\n2001\n6014\n6939\n\nNote\n\nIn the example test, n=2. Thus, there are 3 pigs at minute 1, and 6 pigs at minute 2. There are three queries: x=1, x=5, and x=6.\n\nIf the wolf wants to eat 1 pig, he can do so in 3+6=9 possible attack plans, depending on whether he arrives at minute 1 or 2.\n\nIf the wolf wants to eat 5 pigs, the wolf cannot arrive at minute 1, since there aren't enough pigs at that time. Therefore, the wolf has to arrive at minute 2, and there are 6 possible attack plans.\n\nIf the wolf wants to eat 6 pigs, his only plan is to arrive at the end of the convention and devour everybody.\n\nRemember to output your answers modulo 10^9+7!", "test_cases": ["input: \"2 3\\n1\\n5\\n6\\n\"\noutput: \"9\\n6\\n1\\n\"\n", "input: \"5 4\\n2\\n4\\n6\\n8\\n\"\noutput: \"225\\n2001\\n6014\\n6939\\n\"\n"], "private_tests": ["input: \"1 3\\n1\\n2\\n3\\n\"\noutput: \"3\\n3\\n1\\n\"\n", "input: \"3 9\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n\"\noutput: \"18\\n54\\n105\\n141\\n132\\n85\\n36\\n9\\n1\\n\"\n"], "solutions": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 10;\nlong long mod = 1e9 + 7;\nlong long dp[maxn * 3][3];\nlong long nv[maxn * 3];\nlong long qpow(long long a, long long n) {\n  long long ans = 1;\n  while (n) {\n    if (n & 1) ans = ans * a % mod;\n    a = a * a % mod;\n    n >>= 1;\n  }\n  return ans;\n}\nlong long a[maxn * 3];\nint main() {\n  int n, q, x;\n  long long inv = qpow(3, mod - 2);\n  scanf(\"%d%d\", &n, &q);\n  long long sum = 3 * n;\n  a[0] = 1;\n  dp[0][0] = n;\n  dp[0][1] = n;\n  dp[0][2] = n;\n  nv[1] = 1;\n  for (int i = 2; i <= 3 * n; i++) {\n    nv[i] = mod - mod / i * nv[mod % i] % mod;\n  }\n  for (int i = 1; i <= 3 * n; i++) {\n    a[i] = a[i - 1] * (3 * n - i + 1) % mod * nv[i] % mod;\n    sum = sum * (3 * n - i + mod) % mod * nv[i + 1] % mod;\n    dp[i][0] =\n        (sum - 2 * dp[i - 1][0] - dp[i - 1][1] + 3 * mod) % mod * inv % mod;\n    dp[i][1] = (dp[i][0] + dp[i - 1][0]) % mod;\n  }\n  while (q--) {\n    scanf(\"%d\", &x);\n    printf(\"%lld\\n\", (dp[x][0] + a[x]) % mod);\n  }\n  return 0;\n}\n"}
{"language": "cpp", "Difficulty": "C", "name": "1548_C. The Three Little Pigs", "description": "Three little pigs from all over the world are meeting for a convention! Every minute, a triple of 3 new pigs arrives on the convention floor. After the n-th minute, the convention ends.\n\nThe big bad wolf has learned about this convention, and he has an attack plan. At some minute in the convention, he will arrive and eat exactly x pigs. Then he will get away.\n\nThe wolf wants Gregor to help him figure out the number of possible attack plans that involve eating exactly x pigs for various values of x (1 \u2264 x \u2264 3n). Two attack plans are considered different, if they occur at different times or if the sets of little pigs to eat are different.\n\nNote that all queries are independent, that is, the wolf does not eat the little pigs, he only makes plans!\n\nInput\n\nThe first line of input contains two integers n and q (1 \u2264 n \u2264 10^6, 1 \u2264 q \u2264 2\u22c5 10^5), the number of minutes the convention lasts and the number of queries the wolf asks.\n\nEach of the next q lines contains a single integer x_i (1 \u2264 x_i \u2264 3n), the number of pigs the wolf will eat in the i-th query.\n\nOutput\n\nYou should print q lines, with line i representing the number of attack plans if the wolf wants to eat x_i pigs. Since each query answer can be large, output each answer modulo 10^9+7.\n\nExamples\n\nInput\n\n\n2 3\n1\n5\n6\n\n\nOutput\n\n\n9\n6\n1\n\n\nInput\n\n\n5 4\n2\n4\n6\n8\n\n\nOutput\n\n\n225\n2001\n6014\n6939\n\nNote\n\nIn the example test, n=2. Thus, there are 3 pigs at minute 1, and 6 pigs at minute 2. There are three queries: x=1, x=5, and x=6.\n\nIf the wolf wants to eat 1 pig, he can do so in 3+6=9 possible attack plans, depending on whether he arrives at minute 1 or 2.\n\nIf the wolf wants to eat 5 pigs, the wolf cannot arrive at minute 1, since there aren't enough pigs at that time. Therefore, the wolf has to arrive at minute 2, and there are 6 possible attack plans.\n\nIf the wolf wants to eat 6 pigs, his only plan is to arrive at the end of the convention and devour everybody.\n\nRemember to output your answers modulo 10^9+7!", "test_cases": ["input: \"2 3\\n1\\n5\\n6\\n\"\noutput: \"9\\n6\\n1\\n\"\n", "input: \"5 4\\n2\\n4\\n6\\n8\\n\"\noutput: \"225\\n2001\\n6014\\n6939\\n\"\n"], "private_tests": ["input: \"1 3\\n1\\n2\\n3\\n\"\noutput: \"3\\n3\\n1\\n\"\n", "input: \"3 9\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n\"\noutput: \"18\\n54\\n105\\n141\\n132\\n85\\n36\\n9\\n1\\n\"\n"], "solutions": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, x;\nlong long dp[3300000][4], fac[3300000], inv[3300000], inc[3300000];\nconst int mod = 1e9 + 7, inv3 = 333333336;\nvoid init() {\n  fac[0] = inv[0] = inv[1] = inc[0] = 1;\n  for (int i = 1; i <= 3000000; i++) fac[i] = fac[i - 1] * i % mod;\n  for (int i = 2; i <= 3000000; i++)\n    inv[i] = inv[mod % i] * (mod - mod / i) % mod;\n  for (int i = 1; i <= 3000000; i++) inc[i] = inc[i - 1] * inv[i] % mod;\n  return;\n}\nlong long C(int a, int b) {\n  if (a < b || b < 0) return 0;\n  return fac[a] * inc[b] % mod * inc[a - b] % mod;\n}\nint main() {\n  init();\n  scanf(\"%d%d\", &n, &m);\n  dp[0][0] = dp[0][1] = dp[0][2] = n;\n  for (int i = 1; i <= 3 * n; i++) {\n    dp[i][0] =\n        ((C(3 * n, i + 1) % mod - 2 * dp[i - 1][0] - dp[i - 1][1]) % mod +\n         mod) *\n        inv3 % mod;\n    dp[i][1] = (dp[i][0] + dp[i - 1][0]) % mod;\n    dp[i][2] = (dp[i][1] + dp[i - 1][1]) % mod;\n  }\n  while (m--) {\n    scanf(\"%d\", &x);\n    printf(\"%lld\\n\", (dp[x][0] + C(3 * n, x)) % mod);\n  }\n  return 0;\n}\n"}
{"language": "cpp", "Difficulty": "C", "name": "1548_C. The Three Little Pigs", "description": "Three little pigs from all over the world are meeting for a convention! Every minute, a triple of 3 new pigs arrives on the convention floor. After the n-th minute, the convention ends.\n\nThe big bad wolf has learned about this convention, and he has an attack plan. At some minute in the convention, he will arrive and eat exactly x pigs. Then he will get away.\n\nThe wolf wants Gregor to help him figure out the number of possible attack plans that involve eating exactly x pigs for various values of x (1 \u2264 x \u2264 3n). Two attack plans are considered different, if they occur at different times or if the sets of little pigs to eat are different.\n\nNote that all queries are independent, that is, the wolf does not eat the little pigs, he only makes plans!\n\nInput\n\nThe first line of input contains two integers n and q (1 \u2264 n \u2264 10^6, 1 \u2264 q \u2264 2\u22c5 10^5), the number of minutes the convention lasts and the number of queries the wolf asks.\n\nEach of the next q lines contains a single integer x_i (1 \u2264 x_i \u2264 3n), the number of pigs the wolf will eat in the i-th query.\n\nOutput\n\nYou should print q lines, with line i representing the number of attack plans if the wolf wants to eat x_i pigs. Since each query answer can be large, output each answer modulo 10^9+7.\n\nExamples\n\nInput\n\n\n2 3\n1\n5\n6\n\n\nOutput\n\n\n9\n6\n1\n\n\nInput\n\n\n5 4\n2\n4\n6\n8\n\n\nOutput\n\n\n225\n2001\n6014\n6939\n\nNote\n\nIn the example test, n=2. Thus, there are 3 pigs at minute 1, and 6 pigs at minute 2. There are three queries: x=1, x=5, and x=6.\n\nIf the wolf wants to eat 1 pig, he can do so in 3+6=9 possible attack plans, depending on whether he arrives at minute 1 or 2.\n\nIf the wolf wants to eat 5 pigs, the wolf cannot arrive at minute 1, since there aren't enough pigs at that time. Therefore, the wolf has to arrive at minute 2, and there are 6 possible attack plans.\n\nIf the wolf wants to eat 6 pigs, his only plan is to arrive at the end of the convention and devour everybody.\n\nRemember to output your answers modulo 10^9+7!", "test_cases": ["input: \"2 3\\n1\\n5\\n6\\n\"\noutput: \"9\\n6\\n1\\n\"\n", "input: \"5 4\\n2\\n4\\n6\\n8\\n\"\noutput: \"225\\n2001\\n6014\\n6939\\n\"\n"], "private_tests": ["input: \"1 3\\n1\\n2\\n3\\n\"\noutput: \"3\\n3\\n1\\n\"\n", "input: \"3 9\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n\"\noutput: \"18\\n54\\n105\\n141\\n132\\n85\\n36\\n9\\n1\\n\"\n"], "solutions": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename M, typename N>\nistream &operator>>(istream &is, pair<M, N> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\ntemplate <typename M>\nistream &operator>>(istream &is, vector<M> &v) {\n  for (auto &it : v) is >> it;\n  return is;\n}\ntemplate <typename M>\nistream &operator>>(istream &is, vector<vector<M>> &v) {\n  for (auto &it : v) is >> it;\n  return is;\n}\ntemplate <typename M, typename N>\nostream &operator<<(ostream &os, const pair<M, N> &p) {\n  os << p.first << ' ' << p.second << '\\n';\n  return os;\n}\ntemplate <typename M>\nostream &operator<<(ostream &os, const vector<M> &v) {\n  for (auto it : v) os << it << ' ';\n  cout << '\\n';\n  return os;\n}\ntemplate <typename M>\nostream &operator<<(ostream &os, const vector<vector<M>> &v) {\n  for (auto it : v) os << it;\n  return os;\n}\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int a, int b) { return rng() % (b - a + 1) + a; }\nconst long double eps = 1e-7;\nconst long double pi = acos(-1);\nconst long long inf = (long long)1e9 + 10;\nconst int mod = 1000000007;\nint n, m, k;\nconst int N = 1e6 + 10;\nlong long binpow(long long a, long long b, long long m) {\n  a %= m;\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a % m;\n    a = a * a % m;\n    b >>= 1;\n  }\n  return res;\n}\nvector<long long int> fact, fact_inverse;\ntemplate <typename type>\nvoid tabulate(type n) {\n  fact.resize(n + 1);\n  fact_inverse.resize(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i < n + 1; i++) {\n    fact[i] = fact[i - 1] * i;\n    fact[i] %= mod;\n  }\n  fact_inverse[n] = binpow(fact[n], mod - 2, mod);\n  for (int i = n - 1; i >= 0; i--) {\n    fact_inverse[i] = fact_inverse[i + 1] * (i + 1) % mod;\n  }\n}\ntemplate <typename type>\nlong long int nCk(type n, type k) {\n  return n < k ? 0\n               : fact[n] * fact_inverse[n - k] % mod * fact_inverse[k] % mod;\n}\ntemplate <typename type>\nlong long int nPk(type n, type k) {\n  return n < k ? 0 : fact[n] * fact_inverse[n - k] % mod;\n}\nstruct mint {\n  long long x;\n  mint(){};\n  mint(long long xx) : x(xx) {}\n  mint operator+(const mint &b) {\n    return x + b.x >= mod ? x + b.x - mod : x + b.x;\n  }\n  mint operator-(const mint &b) { return x >= b.x ? x - b.x : x - b.x + mod; }\n  mint operator*(const mint &b) { return x * b.x % mod; }\n  mint operator/(const mint &b) { return *this * inverse(b); }\n  mint operator+=(const mint &b) { return *this = *this + b; }\n  mint operator-=(const mint &b) { return *this = *this - b; }\n  mint operator*=(const mint &b) { return *this = *this * b; }\n  mint operator/=(const mint &b) { return *this = *this / b; }\n  bool operator==(const mint &b) { return x == b.x; }\n  bool operator!=(const mint &b) { return x != b.x; }\n  bool operator<(const mint &b) { return x < b.x; }\n  bool operator>(const mint &b) { return x > b.x; }\n  mint operator++() { return *this = *this + 1; }\n  mint operator--() { return *this = *this - 1; }\n  mint operator-() { return x ? mod - x : 0; }\n  mint operator^(long long e) {\n    mint r = 1;\n    mint xx = x;\n    while (e) {\n      if (e & 1) r *= xx;\n      xx *= xx;\n      e >>= 1;\n    }\n    return r;\n  }\n  mint inverse(mint a) { return a ^ (mod - 2); }\n  friend ostream &operator<<(ostream &os, const mint &m) {\n    os << m.x;\n    return os;\n  }\n  friend istream &operator>>(istream &in, mint &m) {\n    in >> m.x;\n    return in;\n  }\n};\nvector<mint> divide(vector<mint> &a, vector<mint> &b) {\n  int n = (int)a.size(), m = (int)b.size();\n  assert(n >= m);\n  vector<mint> ans(n - m + 1);\n  mint temp, temp1 = (mint)1 / b[m - 1];\n  for (int i = n - 1, l = m - 1; i >= l; i--) {\n    temp = a[i] * temp1;\n    ans[i - m + 1] = temp;\n    for (int j = i - 1, l = i - m + 1; j >= l; j--) {\n      a[j] -= temp * b[m - 1 - i + j];\n    }\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, q;\n  cin >> n >> q;\n  tabulate(3 * n + 10);\n  vector<mint> v(3 * n + 4);\n  for (int i = 0; i <= 3 * n + 3; i++) {\n    v[i] = nCk(3 * n + 3, i);\n  }\n  vector<mint> t = {0, 3, 3, 1};\n  auto ans = divide(v, t);\n  for (int i = 0, u; i < q; i++) {\n    cin >> u;\n    cout << ans[u] << '\\n';\n  }\n  return 0;\n}\n"}
{"language": "cpp", "Difficulty": "C", "name": "1548_C. The Three Little Pigs", "description": "Three little pigs from all over the world are meeting for a convention! Every minute, a triple of 3 new pigs arrives on the convention floor. After the n-th minute, the convention ends.\n\nThe big bad wolf has learned about this convention, and he has an attack plan. At some minute in the convention, he will arrive and eat exactly x pigs. Then he will get away.\n\nThe wolf wants Gregor to help him figure out the number of possible attack plans that involve eating exactly x pigs for various values of x (1 \u2264 x \u2264 3n). Two attack plans are considered different, if they occur at different times or if the sets of little pigs to eat are different.\n\nNote that all queries are independent, that is, the wolf does not eat the little pigs, he only makes plans!\n\nInput\n\nThe first line of input contains two integers n and q (1 \u2264 n \u2264 10^6, 1 \u2264 q \u2264 2\u22c5 10^5), the number of minutes the convention lasts and the number of queries the wolf asks.\n\nEach of the next q lines contains a single integer x_i (1 \u2264 x_i \u2264 3n), the number of pigs the wolf will eat in the i-th query.\n\nOutput\n\nYou should print q lines, with line i representing the number of attack plans if the wolf wants to eat x_i pigs. Since each query answer can be large, output each answer modulo 10^9+7.\n\nExamples\n\nInput\n\n\n2 3\n1\n5\n6\n\n\nOutput\n\n\n9\n6\n1\n\n\nInput\n\n\n5 4\n2\n4\n6\n8\n\n\nOutput\n\n\n225\n2001\n6014\n6939\n\nNote\n\nIn the example test, n=2. Thus, there are 3 pigs at minute 1, and 6 pigs at minute 2. There are three queries: x=1, x=5, and x=6.\n\nIf the wolf wants to eat 1 pig, he can do so in 3+6=9 possible attack plans, depending on whether he arrives at minute 1 or 2.\n\nIf the wolf wants to eat 5 pigs, the wolf cannot arrive at minute 1, since there aren't enough pigs at that time. Therefore, the wolf has to arrive at minute 2, and there are 6 possible attack plans.\n\nIf the wolf wants to eat 6 pigs, his only plan is to arrive at the end of the convention and devour everybody.\n\nRemember to output your answers modulo 10^9+7!", "test_cases": ["input: \"2 3\\n1\\n5\\n6\\n\"\noutput: \"9\\n6\\n1\\n\"\n", "input: \"5 4\\n2\\n4\\n6\\n8\\n\"\noutput: \"225\\n2001\\n6014\\n6939\\n\"\n"], "private_tests": ["input: \"1 3\\n1\\n2\\n3\\n\"\noutput: \"3\\n3\\n1\\n\"\n", "input: \"3 9\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n\"\noutput: \"18\\n54\\n105\\n141\\n132\\n85\\n36\\n9\\n1\\n\"\n"], "solutions": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int X = 3e6 + 20, M = 1e9 + 7;\nint f[X], fi[X];\nvoid dec(int &x, int y) {\n  x -= y;\n  if (x < 0) x += M;\n}\nint mul(ll x, int y) { return x * y % M; }\nint bpow(int a, ll b) {\n  int res = 1;\n  for (; b; b >>= 1, a = mul(a, a))\n    if (b & 1) res = mul(res, a);\n  return res;\n}\nint C(int n, int r) {\n  if (r < 0 || r > n) return 0;\n  return mul(f[n], mul(fi[r], fi[n - r]));\n}\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  f[0] = 1;\n  for (auto i = (1); i < (X); ++i) f[i] = mul(i, f[i - 1]);\n  fi[X - 1] = bpow(f[X - 1], M - 2);\n  for (auto i = (X)-1; i >= (1); --i) fi[i - 1] = mul(i, fi[i]);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(3 * (n + 1));\n  for (int i = 1; i <= 3 * (n + 1); ++i) a[i - 1] = C(3 * (n + 1), i);\n  for (int m = 3 * n + 2; m - 2 >= 0; --m) {\n    int x = mul(a[m], 3);\n    dec(a[m - 1], x);\n    dec(a[m - 2], x);\n  }\n  while (q--) {\n    int x;\n    cin >> x;\n    cout << a[x + 2] << '\\n';\n  }\n}\n"}
{"language": "cpp", "Difficulty": "C", "name": "1548_C. The Three Little Pigs", "description": "Three little pigs from all over the world are meeting for a convention! Every minute, a triple of 3 new pigs arrives on the convention floor. After the n-th minute, the convention ends.\n\nThe big bad wolf has learned about this convention, and he has an attack plan. At some minute in the convention, he will arrive and eat exactly x pigs. Then he will get away.\n\nThe wolf wants Gregor to help him figure out the number of possible attack plans that involve eating exactly x pigs for various values of x (1 \u2264 x \u2264 3n). Two attack plans are considered different, if they occur at different times or if the sets of little pigs to eat are different.\n\nNote that all queries are independent, that is, the wolf does not eat the little pigs, he only makes plans!\n\nInput\n\nThe first line of input contains two integers n and q (1 \u2264 n \u2264 10^6, 1 \u2264 q \u2264 2\u22c5 10^5), the number of minutes the convention lasts and the number of queries the wolf asks.\n\nEach of the next q lines contains a single integer x_i (1 \u2264 x_i \u2264 3n), the number of pigs the wolf will eat in the i-th query.\n\nOutput\n\nYou should print q lines, with line i representing the number of attack plans if the wolf wants to eat x_i pigs. Since each query answer can be large, output each answer modulo 10^9+7.\n\nExamples\n\nInput\n\n\n2 3\n1\n5\n6\n\n\nOutput\n\n\n9\n6\n1\n\n\nInput\n\n\n5 4\n2\n4\n6\n8\n\n\nOutput\n\n\n225\n2001\n6014\n6939\n\nNote\n\nIn the example test, n=2. Thus, there are 3 pigs at minute 1, and 6 pigs at minute 2. There are three queries: x=1, x=5, and x=6.\n\nIf the wolf wants to eat 1 pig, he can do so in 3+6=9 possible attack plans, depending on whether he arrives at minute 1 or 2.\n\nIf the wolf wants to eat 5 pigs, the wolf cannot arrive at minute 1, since there aren't enough pigs at that time. Therefore, the wolf has to arrive at minute 2, and there are 6 possible attack plans.\n\nIf the wolf wants to eat 6 pigs, his only plan is to arrive at the end of the convention and devour everybody.\n\nRemember to output your answers modulo 10^9+7!", "test_cases": ["input: \"2 3\\n1\\n5\\n6\\n\"\noutput: \"9\\n6\\n1\\n\"\n", "input: \"5 4\\n2\\n4\\n6\\n8\\n\"\noutput: \"225\\n2001\\n6014\\n6939\\n\"\n"], "private_tests": ["input: \"1 3\\n1\\n2\\n3\\n\"\noutput: \"3\\n3\\n1\\n\"\n", "input: \"3 9\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n\"\noutput: \"18\\n54\\n105\\n141\\n132\\n85\\n36\\n9\\n1\\n\"\n"], "solutions": "#include <bits/stdc++.h>\nusing namespace std;\nlong long MOD = 1000000007;\nstatic inline long long safe_mod(long long a) {\n  long long res = a % MOD;\n  if (res < 0) res += MOD;\n  return res;\n}\nstatic inline tuple<long long, long long> mult(tuple<long long, long long> a,\n                                               tuple<long long, long long> b) {\n  auto [a0, a1] = a;\n  auto [b0, b1] = b;\n  return {safe_mod((a0 * b0) - (a1 * b1)),\n          safe_mod(a0 * b1 + a1 * b0 - a1 * b1)};\n}\nstatic inline tuple<long long, long long> diff(tuple<long long, long long> a,\n                                               tuple<long long, long long> b) {\n  return {safe_mod(get<0>(a) - get<0>(b)), safe_mod(get<1>(a) - get<1>(b))};\n}\nstatic inline tuple<long long, long long> add(tuple<long long, long long> a,\n                                              tuple<long long, long long> b) {\n  return {(get<0>(a) + get<0>(b)) % MOD, (get<1>(a) + get<1>(b)) % MOD};\n}\nstatic inline vector<tuple<long long, long long>> divide(\n    vector<tuple<long long, long long>> p, tuple<long long, long long> c) {\n  int n = p.size();\n  vector<tuple<long long, long long>> r(n - 1);\n  for (int i = n - 1; i >= 1; i--) {\n    r[i - 1] = p[i];\n    p[i - 1] = diff(p[i - 1], mult(p[i], c));\n  }\n  return r;\n}\nint main(void) {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(14);\n  int n, q;\n  cin >> n >> q;\n  vector<long long> coeffs(3 * n + 4, 1);\n  vector<long long> inv(3 * n + 4, 1);\n  for (int i = 2; i < 3 * n + 4; i++) {\n    inv[i] = MOD - (MOD / i) * inv[MOD % i] % MOD;\n  }\n  for (long long i = 1; i < 3 * n + 4; i++) {\n    coeffs[i] = (((coeffs[i - 1] * (3 * n + 4 - i)) % MOD) * inv[i]) % MOD;\n    if (coeffs[i] < 0) cout << \"OOOOOO \" << i << \" \" << coeffs[i] << \"\\n\";\n  }\n  vector<long long> e_poly_1(3 * n + 4), e_poly_e(3 * n + 4),\n      e2_poly_1(3 * n + 4), e2_poly_e(3 * n + 4);\n  for (int i = 0; i < 3 * n + 4; i++) {\n    if (i % 3 == 0) {\n      e_poly_1[i] = coeffs[i];\n      e_poly_e[i] = 0;\n      e2_poly_1[i] = coeffs[i];\n      e2_poly_e[i] = 0;\n    } else if (i % 3 == 1) {\n      e_poly_1[i] = MOD - coeffs[i];\n      e_poly_e[i] = MOD - coeffs[i];\n      e2_poly_1[i] = 0;\n      e2_poly_e[i] = coeffs[i];\n    } else {\n      e_poly_1[i] = 0;\n      e_poly_e[i] = coeffs[i];\n      e2_poly_1[i] = MOD - coeffs[i];\n      e2_poly_e[i] = MOD - coeffs[i];\n    }\n  }\n  vector<long long> e_div_1(3 * n + 3);\n  vector<long long> e_div_e(3 * n + 3);\n  for (int i = 3 * n + 3; i >= 1; i--) {\n    long long a = e_poly_1[i], b = e_poly_e[i];\n    e_div_1[i - 1] = a;\n    e_div_e[i - 1] = b;\n    e_poly_1[i - 1] = safe_mod(e_poly_1[i - 1] + a + b);\n    e_poly_e[i - 1] = safe_mod(e_poly_e[i - 1] + 2 * b - a);\n  }\n  vector<long long> e2_div_1(3 * n + 3);\n  vector<long long> e2_div_e(3 * n + 3);\n  for (int i = 3 * n + 3; i >= 1; i--) {\n    long long a = e2_poly_1[i], b = e2_poly_e[i];\n    e2_div_1[i - 1] = a;\n    e2_div_e[i - 1] = b;\n    e2_poly_1[i - 1] = safe_mod(e2_poly_1[i - 1] + 2 * a - b);\n    e2_poly_e[i - 1] = safe_mod(e2_poly_e[i - 1] + b + a);\n  }\n  long long inv_3 = inv[3];\n  for (int i = 0; i < q; i++) {\n    int k;\n    cin >> k;\n    long long res = coeffs[k + 1];\n    if (k % 3 == 0) {\n      res = res + e_div_1[k] + e2_div_1[k];\n    } else if (k % 3 == 1) {\n      res = res - e_div_e[k] + e2_div_e[k] - e2_div_1[k];\n      res = res % MOD;\n      if (res < 0) res += MOD;\n    } else {\n      res = res + e_div_e[k] - e_div_1[k] - e2_div_e[k];\n      res = res % MOD;\n      if (res < 0) res += MOD;\n    }\n    cout << (res * inv_3) % MOD << \"\\n\";\n  }\n}\n"}
{"language": "cpp", "Difficulty": "C", "name": "1548_C. The Three Little Pigs", "description": "Three little pigs from all over the world are meeting for a convention! Every minute, a triple of 3 new pigs arrives on the convention floor. After the n-th minute, the convention ends.\n\nThe big bad wolf has learned about this convention, and he has an attack plan. At some minute in the convention, he will arrive and eat exactly x pigs. Then he will get away.\n\nThe wolf wants Gregor to help him figure out the number of possible attack plans that involve eating exactly x pigs for various values of x (1 \u2264 x \u2264 3n). Two attack plans are considered different, if they occur at different times or if the sets of little pigs to eat are different.\n\nNote that all queries are independent, that is, the wolf does not eat the little pigs, he only makes plans!\n\nInput\n\nThe first line of input contains two integers n and q (1 \u2264 n \u2264 10^6, 1 \u2264 q \u2264 2\u22c5 10^5), the number of minutes the convention lasts and the number of queries the wolf asks.\n\nEach of the next q lines contains a single integer x_i (1 \u2264 x_i \u2264 3n), the number of pigs the wolf will eat in the i-th query.\n\nOutput\n\nYou should print q lines, with line i representing the number of attack plans if the wolf wants to eat x_i pigs. Since each query answer can be large, output each answer modulo 10^9+7.\n\nExamples\n\nInput\n\n\n2 3\n1\n5\n6\n\n\nOutput\n\n\n9\n6\n1\n\n\nInput\n\n\n5 4\n2\n4\n6\n8\n\n\nOutput\n\n\n225\n2001\n6014\n6939\n\nNote\n\nIn the example test, n=2. Thus, there are 3 pigs at minute 1, and 6 pigs at minute 2. There are three queries: x=1, x=5, and x=6.\n\nIf the wolf wants to eat 1 pig, he can do so in 3+6=9 possible attack plans, depending on whether he arrives at minute 1 or 2.\n\nIf the wolf wants to eat 5 pigs, the wolf cannot arrive at minute 1, since there aren't enough pigs at that time. Therefore, the wolf has to arrive at minute 2, and there are 6 possible attack plans.\n\nIf the wolf wants to eat 6 pigs, his only plan is to arrive at the end of the convention and devour everybody.\n\nRemember to output your answers modulo 10^9+7!", "test_cases": ["input: \"2 3\\n1\\n5\\n6\\n\"\noutput: \"9\\n6\\n1\\n\"\n", "input: \"5 4\\n2\\n4\\n6\\n8\\n\"\noutput: \"225\\n2001\\n6014\\n6939\\n\"\n"], "private_tests": ["input: \"1 3\\n1\\n2\\n3\\n\"\noutput: \"3\\n3\\n1\\n\"\n", "input: \"3 9\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n\"\noutput: \"18\\n54\\n105\\n141\\n132\\n85\\n36\\n9\\n1\\n\"\n"], "solutions": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e6 + 10, p = 1e9 + 7;\nint n, q, m, c[N], v[N], f[N], e3;\nint Pow(int x, int y) {\n  int t = 1;\n  while (y) {\n    if (y & 1) t = 1ll * t * x % p;\n    x = 1ll * x * x % p;\n    y >>= 1;\n  }\n  return t;\n}\nint C(int x, int y) {\n  if (x < y || !y) return 0;\n  return 1ll * c[x] * v[y] % p * v[x - y] % p;\n}\nint main() {\n  scanf(\"%d%d\", &n, &q);\n  n *= 3;\n  m = n + 3;\n  c[0] = 1;\n  for (int i = 1; i <= m; i++) c[i] = 1ll * c[i - 1] * i % p;\n  v[m] = Pow(c[m], p - 2);\n  for (int i = m; i; i--) v[i - 1] = 1ll * i * v[i] % p;\n  f[0] = n / 3;\n  f[1] = 1ll * n * (n / 3 + 1) / 2 % p;\n  e3 = Pow(3, p - 2);\n  for (int i = 2; i <= n; i++) {\n    int t = C(n + 3, i + 1) - (i == 2);\n    f[i] = 1ll * (1ll * t - 3ll * f[i - 1] - f[i - 2]) % p * e3 % p;\n  }\n  for (int x; q--;) {\n    scanf(\"%d\", &x);\n    printf(\"%d\\n\", (f[x] % p + p) % p);\n  }\n  return 0;\n}\n"}
{"language": "cpp", "Difficulty": "C", "name": "1548_C. The Three Little Pigs", "description": "Three little pigs from all over the world are meeting for a convention! Every minute, a triple of 3 new pigs arrives on the convention floor. After the n-th minute, the convention ends.\n\nThe big bad wolf has learned about this convention, and he has an attack plan. At some minute in the convention, he will arrive and eat exactly x pigs. Then he will get away.\n\nThe wolf wants Gregor to help him figure out the number of possible attack plans that involve eating exactly x pigs for various values of x (1 \u2264 x \u2264 3n). Two attack plans are considered different, if they occur at different times or if the sets of little pigs to eat are different.\n\nNote that all queries are independent, that is, the wolf does not eat the little pigs, he only makes plans!\n\nInput\n\nThe first line of input contains two integers n and q (1 \u2264 n \u2264 10^6, 1 \u2264 q \u2264 2\u22c5 10^5), the number of minutes the convention lasts and the number of queries the wolf asks.\n\nEach of the next q lines contains a single integer x_i (1 \u2264 x_i \u2264 3n), the number of pigs the wolf will eat in the i-th query.\n\nOutput\n\nYou should print q lines, with line i representing the number of attack plans if the wolf wants to eat x_i pigs. Since each query answer can be large, output each answer modulo 10^9+7.\n\nExamples\n\nInput\n\n\n2 3\n1\n5\n6\n\n\nOutput\n\n\n9\n6\n1\n\n\nInput\n\n\n5 4\n2\n4\n6\n8\n\n\nOutput\n\n\n225\n2001\n6014\n6939\n\nNote\n\nIn the example test, n=2. Thus, there are 3 pigs at minute 1, and 6 pigs at minute 2. There are three queries: x=1, x=5, and x=6.\n\nIf the wolf wants to eat 1 pig, he can do so in 3+6=9 possible attack plans, depending on whether he arrives at minute 1 or 2.\n\nIf the wolf wants to eat 5 pigs, the wolf cannot arrive at minute 1, since there aren't enough pigs at that time. Therefore, the wolf has to arrive at minute 2, and there are 6 possible attack plans.\n\nIf the wolf wants to eat 6 pigs, his only plan is to arrive at the end of the convention and devour everybody.\n\nRemember to output your answers modulo 10^9+7!", "test_cases": ["input: \"2 3\\n1\\n5\\n6\\n\"\noutput: \"9\\n6\\n1\\n\"\n", "input: \"5 4\\n2\\n4\\n6\\n8\\n\"\noutput: \"225\\n2001\\n6014\\n6939\\n\"\n"], "private_tests": ["input: \"1 3\\n1\\n2\\n3\\n\"\noutput: \"3\\n3\\n1\\n\"\n", "input: \"3 9\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n\"\noutput: \"18\\n54\\n105\\n141\\n132\\n85\\n36\\n9\\n1\\n\"\n"], "solutions": "#include <bits/stdc++.h>\nconst int N = 3e6 + 100;\nconst int mod = 1e9 + 7;\nlong long ifac[N], fact[N];\nlong long inv[N];\nlong long fp(long long a, long long b) {\n  long long r = 1ll;\n  for (; b; b >>= 1, (a *= a) %= mod)\n    if (b & 1) (r *= a) %= mod;\n  return r;\n}\nint n, q, lim;\nstd::array<long long, 3> acc[N];\nsigned main() {\n  std::ios::sync_with_stdio(0);\n  std::cin.tie(0), std::cout.tie(0);\n  std::cin >> n >> q;\n  lim = N - 1, ifac[0] = fact[0] = inv[0] = inv[1] = 1;\n  for (int i = 1; i <= lim; i++) fact[i] = (fact[i - 1] * i) % mod;\n  ifac[lim] = fp(fact[lim], mod - 2);\n  for (int i = lim - 1; i; --i) ifac[i] = (ifac[i + 1] * (i + 1)) % mod;\n  for (int i = 2; i <= lim; i++) inv[i] = (mod - mod / i) * inv[mod % i] % mod;\n  acc[1] = {(3 * n - 1) * 1ll * n % mod * inv[2] % mod,\n            (3 * n + 1) * 1ll * n % mod * inv[2] % mod,\n            (3 * n + 3) * 1ll * n % mod * inv[2] % mod};\n  for (int i = 2; i <= 3 * n; i++) {\n    long long tmpx = i * 1ll * acc[i - 1][0] % mod;\n    long long tmpy = i * 1ll * acc[i - 1][1] % mod;\n    long long all = fact[3 * n + 1] * ifac[3 * n - i] % mod * inv[i + 1] % mod;\n    acc[i][0] = ((all - tmpx * 2 - tmpy) % mod + mod) % mod * inv[3] % mod;\n    acc[i][1] = (acc[i][0] + tmpx) % mod;\n    acc[i][2] = (acc[i][1] + tmpy) % mod;\n  }\n  while (q--) {\n    int x;\n    std::cin >> x;\n    std::cout << acc[x][2] * ifac[x] % mod << '\\n';\n  }\n}\n"}
{"language": "cpp", "Difficulty": "C", "name": "1548_C. The Three Little Pigs", "description": "Three little pigs from all over the world are meeting for a convention! Every minute, a triple of 3 new pigs arrives on the convention floor. After the n-th minute, the convention ends.\n\nThe big bad wolf has learned about this convention, and he has an attack plan. At some minute in the convention, he will arrive and eat exactly x pigs. Then he will get away.\n\nThe wolf wants Gregor to help him figure out the number of possible attack plans that involve eating exactly x pigs for various values of x (1 \u2264 x \u2264 3n). Two attack plans are considered different, if they occur at different times or if the sets of little pigs to eat are different.\n\nNote that all queries are independent, that is, the wolf does not eat the little pigs, he only makes plans!\n\nInput\n\nThe first line of input contains two integers n and q (1 \u2264 n \u2264 10^6, 1 \u2264 q \u2264 2\u22c5 10^5), the number of minutes the convention lasts and the number of queries the wolf asks.\n\nEach of the next q lines contains a single integer x_i (1 \u2264 x_i \u2264 3n), the number of pigs the wolf will eat in the i-th query.\n\nOutput\n\nYou should print q lines, with line i representing the number of attack plans if the wolf wants to eat x_i pigs. Since each query answer can be large, output each answer modulo 10^9+7.\n\nExamples\n\nInput\n\n\n2 3\n1\n5\n6\n\n\nOutput\n\n\n9\n6\n1\n\n\nInput\n\n\n5 4\n2\n4\n6\n8\n\n\nOutput\n\n\n225\n2001\n6014\n6939\n\nNote\n\nIn the example test, n=2. Thus, there are 3 pigs at minute 1, and 6 pigs at minute 2. There are three queries: x=1, x=5, and x=6.\n\nIf the wolf wants to eat 1 pig, he can do so in 3+6=9 possible attack plans, depending on whether he arrives at minute 1 or 2.\n\nIf the wolf wants to eat 5 pigs, the wolf cannot arrive at minute 1, since there aren't enough pigs at that time. Therefore, the wolf has to arrive at minute 2, and there are 6 possible attack plans.\n\nIf the wolf wants to eat 6 pigs, his only plan is to arrive at the end of the convention and devour everybody.\n\nRemember to output your answers modulo 10^9+7!", "test_cases": ["input: \"2 3\\n1\\n5\\n6\\n\"\noutput: \"9\\n6\\n1\\n\"\n", "input: \"5 4\\n2\\n4\\n6\\n8\\n\"\noutput: \"225\\n2001\\n6014\\n6939\\n\"\n"], "private_tests": ["input: \"1 3\\n1\\n2\\n3\\n\"\noutput: \"3\\n3\\n1\\n\"\n", "input: \"3 9\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n\"\noutput: \"18\\n54\\n105\\n141\\n132\\n85\\n36\\n9\\n1\\n\"\n"], "solutions": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << '(' << p.first << ',' << p.second << ')';\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  os << '{';\n  for (int i = 0; i < (int)v.size(); i++) {\n    if (i) {\n      os << ',';\n    }\n    os << v[i];\n  }\n  os << '}';\n  return os;\n}\nostream &operator<<(ostream &os, const set<int> &se) {\n  os << '{';\n  int now = 0;\n  for (auto x : se) {\n    if (now) {\n      os << ',';\n    }\n    os << x;\n    now++;\n  }\n  os << '}';\n  return os;\n}\nvoid debugg() { cerr << endl; }\ntemplate <class T, class... Args>\nvoid debugg(const T &x, const Args &...args) {\n  cerr << \" \" << x;\n  debugg(args...);\n}\nusing namespace std;\nconst int inf = (1 << 30) - 1;\nconst long long linf = 1LL << 61;\nconst int MAX = 3010000;\nint dy[8] = {0, 1, 0, -1, 1, -1, -1, 1};\nint dx[8] = {-1, 0, 1, 0, 1, -1, 1, -1};\nconst double pi = acos(-1);\nconst double eps = 1e-8;\ntemplate <typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) {\n  if (a > b) {\n    a = b;\n    return true;\n  } else\n    return false;\n}\ntemplate <typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) {\n  if (a < b) {\n    a = b;\n    return true;\n  } else\n    return false;\n}\ntemplate <typename T>\ninline void print(T &a) {\n  int sz = a.size();\n  for (auto itr = a.begin(); itr != a.end(); itr++) {\n    cout << *itr;\n    sz--;\n    if (sz) cout << \" \";\n  }\n  cout << \"\\n\";\n}\ntemplate <typename T1, typename T2>\ninline void print2(T1 a, T2 b) {\n  cout << a << \" \" << b << \"\\n\";\n}\ntemplate <typename T1, typename T2, typename T3>\ninline void print3(T1 a, T2 b, T3 c) {\n  cout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nvoid mark() {\n  cout << \"#\"\n       << \"\\n\";\n}\nlong long pcount(long long x) { return __builtin_popcountll(x); }\nconst int mod = 1e9 + 7;\ntemplate <int mod>\nstruct ModInt {\n  int x;\n  ModInt() : x(0) {}\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n  ModInt &operator+=(const ModInt &p) {\n    if ((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator-=(const ModInt &p) {\n    if ((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator*=(const ModInt &p) {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n  ModInt operator-() const { return ModInt(-x); }\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n  bool operator==(const ModInt &p) const { return x == p.x; }\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while (b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while (n > 0) {\n      if (n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; }\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n  static int get_mod() { return mod; }\n};\nusing mint = ModInt<mod>;\nvector<mint> fac(MAX), finv(MAX), inv(MAX);\nvoid comInit() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (long long i = 2; i < MAX; i++) {\n    fac[i] = fac[i - 1] * i;\n    inv[i] = (mint)mod - inv[mod % i] * (mod / i);\n    finv[i] = finv[i - 1] * inv[i];\n  }\n}\nmint com(long long n, long long k) {\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * finv[k] * finv[n - k];\n}\nmint f[3030303];\nmint g[3] = {3, 3, 1};\nmint h[3030303];\nvoid solve() {\n  int n, q;\n  cin >> n >> q;\n  comInit();\n  for (int i = 1; i <= n * 3 + 3; i++) f[i] = com(n * 3 + 3, i);\n  mint inv = mint(3).inverse();\n  for (int i = 0; i <= n * 3; i++) {\n    h[i] = f[i + 1] * inv;\n    f[i + 2] -= g[1] * h[i];\n    f[i + 3] -= h[i];\n  }\n  while (q--) {\n    int x;\n    cin >> x;\n    cout << h[x] << \"\\n\";\n  }\n}\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"}
